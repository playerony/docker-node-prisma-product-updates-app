================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-11T10:26:52.035Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
prisma/
  migrations/
    20240810110037_init/
      migration.sql
    migration_lock.toml
  schema.prisma
src/
  handlers/
    user.ts
  modules/
    auth.ts
    db.ts
  index.ts
  router.ts
.dockerignore
.gitignore
docker-compose.yml
Dockerfile
package.json
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .dockerignore
================
node_modules

================
File: .gitignore
================
node_modules
# Keep environment variables out of version control
.env

================
File: Dockerfile
================
FROM node:20

WORKDIR /app
COPY package.json package-lock.json ./
RUN npm install
COPY . .
CMD ["npm", "run", "start:prod"]

================
File: docker-compose.yml
================
services: 
  postgresdb:
    image: postgres
    restart: unless-stopped
    env_file: ./.env
    environment:
      - POSTGRES_USER=$POSTGRESDB_USER
      - POSTGRES_PASSWORD=$POSTGRESDB_ROOT_PASSWORD
      - POSTGRES_DB=$POSTGRESDB_DATABASE
    ports:
      - $POSTGRESDB_LOCAL_PORT:$POSTGRESDB_DOCKER_PORT
    volumes:
      - db:/var/lib/postgres
  server:
    depends_on:
      - postgresdb
    build: .
    restart: unless-stopped
    env_file: ./.env
    ports:
      - $NODE_LOCAL_PORT:$NODE_DOCKER_PORT
    environment:
      - DATABASE_URL=$DATABASE_URL
    stdin_open: true
    tty: true

volumes: 
  db:

================
File: package.json
================
{
  "name": "api-design-node-v4",
  "version": "1.0.0",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "start": "tsx ./src/index.ts",
    "start:prod": "npx prisma generate && npm start",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "playerony",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@prisma/client": "^5.18.0",
    "bcrypt": "^5.1.1",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0"
  },
  "devDependencies": {
    "@types/node": "^22.2.0",
    "prisma": "^5.18.0",
    "tsx": "^4.17.0",
    "typescript": "^5.5.4"
  }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "esModuleInterop": true,
  }
}

================
File: prisma/schema.prisma
================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String    @id @default(uuid())
  createdAt DateTime  @default(now())
  name      String    @unique
  password  String
  products  Product[]
}

model Product {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  name      String   @db.VarChar(255)
  userId    String
  belongsTo User     @relation(fields: [userId], references: [id])
  updates   Update[]
}

enum UPDATE_STATUSES {
  IN_PROGRESS
  SHIPPED
  DEPRECATED
}

model Update {
  id           String          @id @default(uuid())
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  title        String          @db.VarChar(255)
  content      String
  status       UPDATE_STATUSES @default(IN_PROGRESS)
  version      String?
  asset        String?
  productId    String
  product      Product         @relation(fields: [productId], references: [id])
  updatePoints UpdatePoint[]
}

model UpdatePoint {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  name        String   @db.VarChar(255)
  description String
  updateId    String
  update      Update   @relation(fields: [updateId], references: [id])
}

================
File: src/index.ts
================
import * as dotenv from 'dotenv';
dotenv.config();
import express from 'express';
import morgan from 'morgan';

import router from './router';
import { protectMiddleware } from './modules/auth';
import { createUser, signIn } from './handlers/user';

const app = express();
const port = process.env.NODE_DOCKER_PORT || 3000;

app.use(morgan('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.get('/', (_, response) => {
  response.status(200);
  response.send('Hello World!');
});

app.use('/api', protectMiddleware, router);
app.post('/user', createUser);
app.post('/signin', signIn);

app.listen(port, () => {
  console.log(`Server is running on PORT ${port}`);
});

================
File: src/router.ts
================
import { Router } from 'express';

const router = Router();

router.get('/product', (request, response) => { });
router.get('/product/:id', (request, response) => { });
router.post('/product', (request, response) => { });
router.put('/product/:id', (request, response) => { });
router.delete('/product/:id', (request, response) => { });

router.get('/update', (request, response) => { });
router.get('/update/:id', (request, response) => { });
router.post('/update', (request, response) => { });
router.put('/update/:id', (request, response) => { });
router.delete('/update/:id', (request, response) => { });

router.get('/update-point', (request, response) => { });
router.get('/update-point/:id', (request, response) => { });
router.post('/update-point', (request, response) => { });
router.put('/update-point/:id', (request, response) => { });
router.delete('/update-point/:id', (request, response) => { });

export default router;

================
File: prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"

================
File: src/handlers/user.ts
================
import { comparePassword, createToken, hashPassword } from '../modules/auth';
import prisma from '../modules/db';

export const createUser = async (request, response) => {
  const hasedPassword = await hashPassword(request.body.password);

  const user = await prisma.user.create({
    data: {
      name: request.body.name,
      password: hasedPassword,
    },
  });

  const token = createToken({ id: user.id, name: user.name });

  response.json({ token });
}

export const signIn = async (request, response) => {
  const foundUser = await prisma.user.findUnique({
    where: {
      name: request.body.name,
    },
  });

  if (!foundUser) {
    return response.status(401).json({ message: 'Invalid credentials' });
  }

  const isPasswordValid = await comparePassword(request.body.password, foundUser.password);

  if (!isPasswordValid) {
    return response.status(401).json({ message: 'Invalid credentials' });
  }

  const token = createToken({ id: foundUser.id, name: foundUser.name });

  response.json({ token });
}

================
File: src/modules/auth.ts
================
import jwt from 'jsonwebtoken';
import * as bcrypt from 'bcrypt';

export const createToken = ({ id, name }) => {
  const token = jwt.sign({ id, name }, process.env.JWT_SECRET, {
    expiresIn: '1h',
  });

  return token;
}

export const protectMiddleware = (request, response, next) => {
  const fullToken = request.headers.authorization;

  if (!fullToken) {
    return response.status(401).send('Unauthorized');
  }

  const [prefix, token] = fullToken.split(' ');
  if (prefix !== 'Bearer') {
    return response.status(401).send('Unauthorized');
  }

  try {
    const tokenPayload = jwt.verify(token, process.env.JWT_SECRET);
    request.user = tokenPayload;
    next();
  } catch (error) {
    return response.status(401).send('Unauthorized');
  }
}

export const comparePassword = async (password, hash) => {
  return bcrypt.compare(password, hash);
}

export const hashPassword = async (password) => {
  return bcrypt.hash(password, 10);
}

================
File: src/modules/db.ts
================
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default prisma;

================
File: prisma/migrations/20240810110037_init/migration.sql
================
-- CreateEnum
CREATE TYPE "UPDATE_STATUSES" AS ENUM ('IN_PROGRESS', 'SHIPPED', 'DEPRECATED');

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "name" TEXT NOT NULL,
    "password" TEXT NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Product" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "name" VARCHAR(255) NOT NULL,
    "userId" TEXT NOT NULL,

    CONSTRAINT "Product_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Update" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "content" TEXT NOT NULL,
    "status" "UPDATE_STATUSES" NOT NULL DEFAULT 'IN_PROGRESS',
    "version" TEXT,
    "asset" TEXT,
    "productId" TEXT NOT NULL,

    CONSTRAINT "Update_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "UpdatePoint" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "name" VARCHAR(255) NOT NULL,
    "description" TEXT NOT NULL,
    "updateId" TEXT NOT NULL,

    CONSTRAINT "UpdatePoint_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_name_key" ON "User"("name");

-- AddForeignKey
ALTER TABLE "Product" ADD CONSTRAINT "Product_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Update" ADD CONSTRAINT "Update_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UpdatePoint" ADD CONSTRAINT "UpdatePoint_updateId_fkey" FOREIGN KEY ("updateId") REFERENCES "Update"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
